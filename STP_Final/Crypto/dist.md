# crypto 1

## Flag
* `TCP1P{prime_prime_prime_prime_prime_prime_prime_prime_prime_prime}`
## Overview

The challenge defines a prime number constructed as:

p = a^51 + 51 * b^51

where:
- a > 0
- b > 0
- p is prime

The flag is encrypted using:

ciphertext = flag XOR SHA512(str(a) || str(b))

---
## Solution 

The equation 

a^51 + 51 * b^51 ≡ 0 (mod p)

can be rearranged as:

a^51 ≡ -51 * b^51 (mod p)

Since p is prime, arithmetic can be performed in the multiplicative group modulo p.

---

Now,

k = inverse(51, p - 1)

Using Fermat’s Little Theorem, we raise both sides to the power k:

a ≡ (-51)^k * b (mod p)

Define:

r = (-51)^k mod p

This yields a linear modular relationship:

a ≡ r * b (mod p)

---

The congruence:

a - r*b ≡ 0 (mod p)

implies that the vector (b, a) lies in the lattice generated by:

v1 = (1, r)  
v2 = (0, p)

Any lattice vector can be written as:

(b, a) = b*(1, r) + k*(0, p)

for some integer k.

---

The values a and b are significantly smaller than p.

Therefore, (b, a) corresponds to a short vector in this lattice.

Finding short vectors in a two-dimensional lattice is efficiently solvable using Gauss lattice reduction, which is the 2D analogue of the LLL algorithm.

---

Gauss reduction iteratively:
1. Orders basis vectors by length
2. Removes integer projections
3. Minimizes vector norms

After reduction, one of the basis vectors corresponds to:

(±b, ±a)

---

Each reduced vector (x, y) is tested by direct substitution:

x^51 + 51 * y^51 == p  
or  
y^51 + 51 * x^51 == p

---

From this, i got the value of `a=10835766216613383506` and `b=6219413745182497707`, thus 

key = SHA512(str(a) || str(b))
key = SHA512(str(10835766216613383506) || str(6219413745182497707))

The original flag is obtained via:

flag = ciphertext XOR key

---
## Solve script
```python
from Crypto.Util.number import inverse
from hashlib import sha512
from pwn import xor

p = "1cec7c3ff93ca538e71f334e83d905eabd894729a1b515b89dc2392036bc7e5d59fad2c35dbb0a8903c8bb2e9cd5e4779a92d3f361eb1ce9fa2530c47881a8719763f828360138373ffa2ce627f8ccad08e9b5ead178c614f7899adc6a14fa33aa2216c463a04041e78cffa2c68963c6ff422a076bedd32236282eb3bd1b7ba870a3b1c8f639cd536cba329b10a6cf7b4ef78bd11052ff8a0d432fb6d3b221742aa1da6914876e94aca5abdaeef30acdfc90cbc621245ad288a634e8bdf4152ea8ed0062c872ace7b4011dc5743fa9c424413f4e3e8fa5c5513fd4a711141f2ef68c01177f78945db623ac6cc762a6813f11cc278a143ea657bf309e281ef59048a29f279c9ad8b37f221ac06242f577bba985a2aaec051d95391a9681f905472f4e7d1322da492639ee4a5ac776a476cece55f9dfb782c1ef869deed2226691d3157fbb6b131968ebfb1fe5bc1e44a158f1e2321c001355cc9cb3344f6b09b78d965a807cd60d58a9efbab8c6d4f75c8e5ac7c9cf0e5409b55bb2133129272685913be02166c6bffe3747ccd186b6c26fc9f09"
ct= "43edcf6275293ce97d716f49875c4bdba37f6ab30f15a53f09b72bf3816edf6b92618fb56d569d911b2f6fe7a36d4a854022dddf671dc89b4800bc1605822aab72d3"

p = int(p, 16)
ciphertext = bytes.fromhex(ct)


# --- basic vector helpers ---
def norm(v):
    return v[0]*v[0] + v[1]*v[1]

def dot(u, v):
    return u[0]*v[0] + u[1]*v[1]


def gauss_reduce(u, v):
    while True:
        if norm(v) < norm(u):
            u, v = v, u

        mu = dot(u, v) // norm(u)
        if mu == 0:
            return u, v

        v = (v[0] - mu*u[0], v[1] - mu*u[1])

# modular ratio
inv_exp = inverse(51, p - 1)
ratio = pow(-51 % p, inv_exp, p)

# lattice basis
basis_1 = (1, ratio)
basis_2 = (0, p)

short_1, short_2 = gauss_reduce(basis_1, basis_2)


def try_recover(x, y):
    x, y = abs(x), abs(y)
    if x <= 0 or y <= 0:
        return None

    if x**51 + 51*y**51 == p:
        return x, y
    if y**51 + 51*x**51 == p:
        return y, x

    return None


for u, v in (short_1, short_2):
    res = try_recover(u, v)
    if res:
        a, b = res
        key = sha512((str(a) + str(b)).encode()).digest()
        flag = xor(ciphertext, key)
        print('a=', a)
        print('b=', b)
        print(flag.decode())
        break
```
